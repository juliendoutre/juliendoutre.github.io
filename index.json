[{"content":" How do computers understand and store numbers? Introduction #If you followed mathematics courses you\u0026rsquo;re probably aware there are several types of numbers. Natural numbers (also known as positive integers), relative integers with which come the notion of negative numbers, rationals which are a ratio of two relative numbers (ü§Ø), irrationals which can\u0026rsquo;t be expressed as a fraction (like \\(\\pi\\)), reals which are the union of rationals and irrationals, and finally complex numbers which can be seen as a pair of two reals.\nHowever when starting coding, one may find those abstractions lacking and instead encounter weird types such as in Golang: uint8, int32 or float64. In this first article about computers and mathematics, let\u0026rsquo;s try to understand what they mean and how they relate to \u0026ldquo;actual\u0026rdquo; numbers.\nBase 2 #First we need to realize that computers are just a bunch of switches connected together in a smart way.\nA switch can be in one of two states: open or closed, which computer scientists chose to name 0 and 1. Some people also call them false and true, which makes more sense when working with propositions rather than numbers.\nA major contributor to propositional logic based on these premises was George Boole, hence it is often referenced as boolean algebra. One can combine multiple switches to store a sequence (or vector) of bits, that is to say, an ordered list of 0 and 1. For instance 01010111 is a sequence of 8 bits. For historical reasons, a sequence of such a length is called a \u0026ldquo;byte\u0026rdquo;.\nAnd then comes a very interesting result thanks to euclidian division: any natural number can be expressed as such a sequence. Think about it, let\u0026rsquo;s take a number like \\(13\\). If we divide it by \\(2\\), we obtain \\(13 = 2 * 6 + 1\\). If we decompose \\(6\\) itself, we obtain \\(13 = 2 * (2 * 3) + 1\\) and by decomposing \\(3\\) itself we get \\(13 = 2 * (2 * (2 * 1 + 1)) + 1\\). Once developped and grouped by power of two we obtain \\(13 = 2^3 + 2^2 + 1\\).\nStart seeing a pattern here? Let\u0026rsquo;s write the same expression again but showing all powers of two:\n\\(13 = 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0\\)\nIn mathematics, any number power 0 gives 1, so \\(2^0 = 1\\). What if we only took the ones and zeros from the previous expression and put them in a list? We\u0026rsquo;d get 1101. Et voil√†, we wrote our initial number, \\(13\\), in a different writing base, in this case, in base 2 üéâ!\nNote that you can use many different bases to write a number but since computers can only understand open or close switches we are only interested in base 2!\nIn this case we wrote the successive powers from the left to the right in descending order. This is called the most significant bit (MSB) notation but you can write in the other direction and get 1011 which is named least significant bit (LSB) notation. The operation of taking a decimal written number and transform it in a base 2 number can be reversed. If we take our previous byte 01010111, we can compute it as:\n\\(0 * 2^7 + 1 * 2^6 + 0 * 2^5 + 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 87\\)\nCan you tell from a base 2 written number if it\u0026rsquo;s odd or even in less than a second? For sure! Check its last bit. If it\u0026rsquo;s zero, it is even, if it\u0026rsquo;s one, it is odd. Natural integers #Thanks to this ground work definition we can now work with any natural number! Right?\nRight?\nWell the thing is computers have limited resources. You can\u0026rsquo;t write numbers bigger than the maximum number of switches you have available. Most electronic chips are designed to handle numbers with the following sizes:\n8 bits (aka a \u0026ldquo;byte\u0026rdquo;): this is the smallest size available on most computers. 16 bits 32 bits 64 bits: this is the biggest size available. Those are often available under types such as unsigned integer \u0026lt;N\u0026gt; or uint\u0026lt;N\u0026gt; with N being one of 8, 16, 32 or 64.\nYou can always write a number with more switches than it takes to store it: just add zeros to its left until you reach the right size. For instance 13 is represented as 00001101 on a single byte.\nHowever you can\u0026rsquo;t write a number with less switches than it\u0026rsquo;s base 2 size and expect things to work well! This may sound like an edge case but think about operations like multiplications. If we wanna stay on a byte only and multiply 10000000 and 10111010 together, the result won\u0026rsquo;t fit! This is what is called an integer overflow.\nHowever with 64 bits, you can store numbers as big as \\(18‚ÄØ446‚ÄØ744‚ÄØ073‚ÄØ709‚ÄØ551‚ÄØ615\\) which should be able to cover most of your use cases üòÅ\nRelative integers #What about negative integers?\nOne simple way of supporting them would be to add one extra bit to natural integers to indicate their sign. In this case, \\(13\\) would be spelled 000001101, and \\(-13\\) 100001101.\nThat works but this is not super convenient, our microships can\u0026rsquo;t really handle 9-bits numbers\u0026hellip; ü§î\nOk, let\u0026rsquo;s keep 8-bits numbers (or multiples of 8-bits) but use their first bit as a signing bit. We won\u0026rsquo;t be able to store relative numbers as big as natural ones (this covers \\(\\rrbracket-128;128\\llbracket\\) instead of \\(\\rrbracket-256;256\\llbracket\\)) but it\u0026rsquo;ll be easier for everyone. In this case \\(-13\\) writes as 10001101.\nIt\u0026rsquo;s better but what about 0? With this schema, both 10000000 and 00000000 would be acceptable notations. This is a bit awkward\u0026hellip;\nHopefully, there\u0026rsquo;s a solution named the two\u0026rsquo;s complement method.\nTODO\nRelative integers are often available under types such as integer \u0026lt;N\u0026gt; or int\u0026lt;N\u0026gt; with N being one of 8, 16, 32 or 64.\nRational numbers #We could write rational numbers as a couple of two relative numbers, the numerator and the denominator. However this writing would be unique only if those two numbers are coprime. This would put a lot of responsabilities on the developer to put the right numbers ahead of time. Instead we\u0026rsquo;ll just try to use the same method to describe all real numbers.\nReal numbers #As we already emphasized, computers have finite resources. And therefore, they can\u0026rsquo;t describe or manipulate numbers with an infinite sequence of digits. So basically, computers can\u0026rsquo;t reason about \\(\\frac{1}{3}\\) or \\(\\pi\\).\nHowever they can reason about an approximated value with a certain error margin. Here comes a notion well known by physicists: scientific notation.\n$$ \\pi \\approx 3.18309886184*10^0 $$\n$$ \\frac{1}{3} \\approx 3.33*10^{-1} $$\nThe trick is basically to separate a number in two parts:\na mantissa which stores the significant digits for the number. an exponent which stores the power of \\(10 \\) to apply to the mantissa to \u0026ldquo;shift\u0026rdquo; the comma to the right position. This is why they are called floating numbers, the comma is \u0026ldquo;floating\u0026rdquo; in the mantissa according to the exponent\u0026rsquo;s value.\nBoth the mantissa and the and exponent can be stored as signed integers, but that does not mean the same thing:\nif the mantissa is negative, the number is negative if the exponent is negative, the number belongs to \\(]-1;1[\\) People agreed on the IEEE 754 standard to define the length of the mantissa and exponents. Two formats emerged, to accomodate different bit sizes:\n32 bits floating numbers: 23 bits mantissa + 1 bit to indicate the number\u0026rsquo;s sign + 8 bits exponent 64 bits floating numbers: 52 bits mantissa + 1 bit to indicate the number\u0026rsquo;s sign + 11 bits exponent And yes the sign is actually stored in a dedicated bit so we can define \\(0\\) in two different ways which is weird. The format also supports special values to indicate \\(\\infty\\) and \\(-\\infty\\) or an indeterminate form (often called NaN for \u0026ldquo;Not a Number\u0026rdquo; in computer science).\nAnyway, with those two new types at hand (float32 and float64 in Golang for instance) one can describe numbers in \\(]-3.4 * 10^{38} ; -1.2 * 10^{-38}[ \\cup \\{ 0 \\} \\cup ]1.2 * 10^{-38} ; 3.4 * 10^{38}[\\) and \\(]-1.8 * 10^{308} ; -2.2 * 10^{-308}[ \\cup \\{ 0 \\} \\cup ]2.2 * 10^{-308} ; 1.8 * 10^{308}[\\) respectively.\nComplex numbers #We\u0026rsquo;re close to the end of our journey! There\u0026rsquo;s one last category of numbers. They\u0026rsquo;re not pretty common but are powerful enough to deserve a mention here: complex numbers. They are not called this way because they are difficult to understand but rather because they work like a complex composed of two units, a real part and an imaginary one. And therefore, a complex number can simply be seen as a pair of two reals.\nUsually, programming language don\u0026rsquo;t support complex numbers by default so you have to import external libraries or define them yourselves as a new composite type:\ntype complex64 struct { real float32 imaginary float32 } Then it\u0026rsquo;s up to you to define operations on them!\nSome languages like Golang actually do provides native complex64 (two float32s) and complex128 (two float64s) types. Conclusion #Wow, that was a lot! Let\u0026rsquo;s do a quick recap:\ncomputers can only \u0026ldquo;understand\u0026rdquo; natural numbers written in base 2 because they are just a bunch of switches. mathematics are not limited by the physical world: imagination (and therefore coffee ‚òï) is the only limit! When dealing with computers, you always need to take into account the hardware you\u0026rsquo;re working with. relative numbers require a small trick to be efficiently understood by computers: the two\u0026rsquo;s complement method. real numbers are lies, they can only be stored as approximated values. with all these primitives established, one can build more abstractions such as complex numbers, vectors, whatever you want really! In the next post, we\u0026rsquo;ll talk about another interesting mathematical beast: functions!\nSee you next time üëã\n","date":"2024-03-25","permalink":"/posts/do-computers-dream-of-imaginary-numbers/","section":"Posts","summary":"How do computers understand and store numbers?","title":"Do computers dream of imaginary numbers?"},{"content":"","date":null,"permalink":"/","section":"Julien Doutre","summary":"","title":"Julien Doutre"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"I wanted to have my own blog for a long time. Finally, some day last week, I found the time to set up one. This article will reflect on my thought process and the stack I ended up choosing.\nMy requirements were pretty straigthforward. I wanted:\nto write posts using just markdown. I\u0026rsquo;m not a fan of fancy text editors, they\u0026rsquo;re not reactive enough. Being able to write in my IDE (vscode) where I already manage my code and my terminal makes it easier for me to gather all my tools at the same place. to host the website myself, not just posting on Medium or Wordpress for instance. I wanted to be able to control the very content I would expose publically from the articles\u0026rsquo; body to the pages\u0026rsquo; HTML. the solution to be as cheap as possible. Do I really need to elaborate? Additionally, I did not want to build something from scratch, especially not relying on JS frameworks like React which are way too overkill for small projects. Moreover I\u0026rsquo;m not a frontend engineer, I\u0026rsquo;m really bad at drawing with CSS (I still struggle centering \u0026lt;div\u0026gt; inside flex boxes, how do these guys have their tags behave as they want them to?! ü§Ø).\nNaturally, the go-to for static websites supporting markdown is Hugo. It did not take me a lot of time to realize it was a perfect fit for my use case:\nbrew install hugo hugo new site juliendoutre.github.io and I had my project initialized.\nhugo serve and I had a locally version of the website running.\nWhat took me the most time to figure out was obviously (and as foresaw my friend Edouard) which theme to use.\nI had vague memories of the Gitbook project which I liked the chapter-based organization with a nice vertical left side panel. I checked their website and noticed they stopped supporting their self-hosted solution to focus on a SAAS platform. Too bad ü§∑ Plus it did not really fit a blog post use case, missing a lot of features I could find elsewhere.\nAfter exploring the Hugo theme showcase I ended up choosing the Congo theme which was appealing to me for the following reasons:\nit has a search bar it has a dark mode the home page can show as a profile page configuration options are crystal clear it uses Tailwind and I heard it\u0026rsquo;s the cool new thing. The only non-trivial customization was changing the default flaticon. I had to lookup some other persons\u0026rsquo; blogs source code to find the right file names to use in the static folder of my project.\nRegarding the hosting, I considered for a second deploying everything in my AWS account using S3 and CloudFront. But in the end, GitHub pages is easier to use, integrates seamlessly with GitHub actions, plus it\u0026rsquo;s free (I don\u0026rsquo;t even have to pay for a domain name)!\nMy current development workflow is pushing to the main branch, waiting for the GitHub action to generate the public folder to the gh-pages branch, which is then served by GitHub pages on the domain matching the repository\u0026rsquo;s name. I\u0026rsquo;ll see how this can be improved in the future!\nIn the meantime, if you\u0026rsquo;re curious, you can check this website source code at https://github.com/juliendoutre/juliendoutre.github.io ü§ì\nSee you next time üëã\n","date":"2023-04-03","permalink":"/posts/how-i-built-this-website/","section":"Posts","summary":"I wanted to have my own blog for a long time.","title":"How I built this website"},{"content":"This is the first post on this website!\n","date":"2023-03-31","permalink":"/posts/hello-world/","section":"Posts","summary":"This is the first post on this website!","title":"Hello World!"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"Books I enjoyed reading and recommend checking out!\n","date":"0001-01-01","permalink":"/readings/","section":"Julien Doutre","summary":"Books I enjoyed reading and recommend checking out!","title":"Readings"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]